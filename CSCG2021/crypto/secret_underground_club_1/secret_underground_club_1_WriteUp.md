# Secret Underground Club 1

Category: Cryptography
Created: Mar 1, 2021 9:24 PM
Solved: Yes
Subjective Difficulty: 🔥🔥

# WriteUp:

Author: @Tibotix

This was a challenge in the CSCG2021 Competition.

## 📃 Challenge Description:

Can you be part of the secret underground club?

## 🔎 Research:

When looking at the source code we can see that we somehow need to provide a message and a signature so that this equation is true:

`message == pow(signature, e, n)`  | where e and n are the numbers from the server-side generated RSA public key that will be sent to us

This will basically just verify the given message based on the given public key.

## 📝 Vulnerability Description:

The program does not ask the signature for a *specific* message. Instead we can provide our own message with its own signature. This allowing to provide a valid signature without knowing the private key of the key pair generated at the server. 
A signature generation would go as follows:

`sig = message**d mod(n)`   | where d is the private key

A signature verification on the other hand would go:

`message == sig**e mod(n)` ,  where the verification would success if this equation is true.

So when we are given a message to sign, we calculate the signature based on the message.

But when we have the freedom to choose our own message, we can simply set a random signature and calculate the related message to it. In this way we don't even need to know the private key `d` . 

## 🧠 Exploit Development:

Lets set the signature to `0xdeadbeef`, 
and calculate the related message with

`mes = sig**e mod(n)`.

## 🔐 Exploit Program:

```python
from pwn import *

p = remote("7b000000033d6bef33a6ffd0-secretundergroundclub1.challenge.broker.cscg.live", 31337, ssl=True)

p.recvuntil("e=")
e = int(p.recvuntil('\n').strip(), 16)
p.recvuntil("n=")
n = int(p.recvuntil('\n').strip(), 16)

log.info("e: {0}".format(hex(e)))
log.info("n: {0}".format(hex(n)))

signature = 0xdeadbeef
message = pow(signature, e, n)
log.info("signature: {0}".format(hex(signature)))
log.info("message: {0}".format(hex(message)))

p.recvuntil("Message:")
p.sendline(hex(message))

p.recvuntil("Signature:")
p.sendline(hex(signature))

p.interactive()
```

## 💥 Run Exploit:

![images/Untitled.png](images/Untitled.png)

**FLAG: CSCG{rsa_seems_easy_but_apparently_it_is_not}**

## 🛡️ Possible Prevention:

The usage of the RSA algorithm to verify the signature in this case is misused. The signature should only be generated by the one holding the private key.

## 🗄️ Summary / Difficulties:

Always pay attention to how you use cryptographically functions.

## 🗃️ Further References:

[RSA (cryptosystem) - Wikipedia](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) 

## 🔨 Used Tools:

- python
- pwntools

